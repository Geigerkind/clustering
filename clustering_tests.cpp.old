#include<iostream>
#include<fstream>
#include<vector>
#include<math.h>
#include<chrono>
#include <iterator>

#include <pthread.h>
#include <stdlib.h>

/*
* Stuff to generate python graph code for the clustering algo
*/
std::ofstream python_init_graph(int grid_size, int target_size)
{
    std::ofstream stream(std::to_string(grid_size) + std::string("_") + std::to_string(target_size) + std::string("_plot.py"));
    stream << "import matplotlib.pyplot as plt" << std::endl;
    stream << "fig = plt.figure()" << std::endl;
    return stream;
}
void python_plot(std::ofstream &stream, std::vector<std::pair<int,int>> &points, bool point = false)
{
    std::vector<int> xAxis;
    std::vector<int> yAxis;
    for (auto entry : points)
    {
        xAxis.push_back(entry.first);
        yAxis.push_back(entry.second);
    }

    stream << "plt.plot([";
    for (int q = 0; q< xAxis.size()-1; ++q)
        stream << xAxis[q] << ",";
    stream << xAxis[xAxis.size()-1] << "]";

    stream << ",[";
    for (int q = 0; q< yAxis.size()-1; ++q)
        stream << yAxis[q] << ",";
    stream << yAxis[yAxis.size()-1] << "]" << (point ? ",'o'" : "") << ")" << std::endl;
}
void python_generate(std::ofstream &stream, int grid_size, int target_size)
{
    stream << "fig.savefig('" << grid_size << "_" << target_size << ".png')" << std::endl;
    stream.close();
}


/*
* Different clustering implementations
*/
void clustering_v1(std::ofstream &stream, std::vector<std::pair<int,int>> &P_external_set, std::vector<std::pair<int,int>> &updated_external_set, int N_max_size_external_set)
{
    // Step 1: 
    // Create a set of sets of clusters
    std::vector<std::vector<std::pair<int,int>>> c_cluster_set;
    c_cluster_set.reserve(P_external_set.size());
    
    for (auto &entry : P_external_set)
    {
        std::vector<std::pair<int,int>> cluster;
        cluster.reserve(1);
        cluster.push_back(entry);
        c_cluster_set.push_back(std::move(cluster));
    }

    // Step 2: Goto step 5 if the set contains lesser or equal to max specified number
    while (c_cluster_set.size() > N_max_size_external_set)
    {
        // Step 3: Find the two sets with the minimum distance to each other
        // O (N^2) atm btw.
        // Note: Should be symmetric tho
        std::vector<std::pair<std::pair<int,int>, double>> solution_set;
        solution_set.reserve(c_cluster_set.size() * c_cluster_set.size());
        int i = 0;
        for (auto &cluster_1 : c_cluster_set)
        {
            int j = -1;
            for (auto &cluster_2 : c_cluster_set)
            {
                ++j;
                // If it is literally the same cluster, we want to continue
                if (&cluster_1 == &cluster_2)
                    continue;

                // This is supposed to be this d function
                double distance = 0.0;
                for (auto &cluster_1_entry : cluster_1)
                for (auto &cluster_2_entry : cluster_2)
                {
                    // Euklidian distance I suppose
                    distance += sqrt((cluster_1_entry.first-cluster_2_entry.first) * (cluster_1_entry.first-cluster_2_entry.first) + (cluster_1_entry.second-cluster_2_entry.second)*(cluster_1_entry.second-cluster_2_entry.second));
                }

                distance = (1.0/(cluster_1.size()*cluster_2.size())) * distance;
                solution_set.push_back(std::make_pair(std::make_pair(i,j), distance));
            }
            ++i;
        }

        // Step 4: Find pair with minimal distance
        std::pair<int,int> min_distance_pair = solution_set[0].first;
        double min_distance = solution_set[0].second;
        for (int k=1; k<solution_set.size(); ++k)
        {
            auto entry = solution_set[k];
            if (entry.second >= min_distance)
                continue;

            min_distance_pair = entry.first;
            min_distance = entry.second;
        }

        // Now merge the sets and create a new clusterset
        std::vector<std::pair<int,int>> new_cluster;
        new_cluster.reserve(c_cluster_set[min_distance_pair.first].size() * c_cluster_set[min_distance_pair.second].size());
        for (auto entry : c_cluster_set[min_distance_pair.first])
            new_cluster.push_back(entry);
        for (auto entry : c_cluster_set[min_distance_pair.second])
            new_cluster.push_back(entry);

        // Vectors are a little inefficient for that, but this algorithm is not efficient anyway
        if (min_distance_pair.first < min_distance_pair.second)
        {
            c_cluster_set.erase(c_cluster_set.begin()+min_distance_pair.first);   
            c_cluster_set.erase(c_cluster_set.begin()+min_distance_pair.second-1); // -1 because the position will shift by one   
        }
        else
        {
            c_cluster_set.erase(c_cluster_set.begin()+min_distance_pair.second);   
            c_cluster_set.erase(c_cluster_set.begin()+min_distance_pair.first-1); // -1 because the position will shift by one   
        } 
        c_cluster_set.push_back(new_cluster);
    }

    // DEBUG: To see what is clustered
    for(auto cluster : c_cluster_set)
        python_plot(stream, cluster);

    // Step 5: Return set of center points of each cluster
    updated_external_set.reserve(c_cluster_set.size());
    for(auto cluster : c_cluster_set)
    {
        // This is supposed to be this d function
        double min_distance;
        std::pair<int,int> min_distance_pair;
        bool firstOne = true;
        for (auto &cluster_entry_1 : cluster)
        {
            double distance = 0.0;
            for (auto &cluster_entry_2 : cluster)
            {
                // Ignore the same point
                if (&cluster_entry_1 == &cluster_entry_2)
                    continue;

                // Euklidian distance I suppose
                distance += sqrt((cluster_entry_1.first-cluster_entry_2.first) * (cluster_entry_1.first-cluster_entry_2.first) + (cluster_entry_1.second-cluster_entry_2.second)*(cluster_entry_1.second-cluster_entry_2.second));
            }

            if (!firstOne && min_distance <= distance)
                continue;

            min_distance = distance;
            min_distance_pair = cluster_entry_1;
            firstOne = false;
        }
        updated_external_set.push_back(std::move(min_distance_pair));
    }
}

void clustering_v2(std::ofstream &stream, std::vector<std::pair<int,int>> &P_external_set, std::vector<std::pair<int,int>> &updated_external_set, int N_max_size_external_set)
{
    // Step 1: 
    // Create a set of sets of clusters
    std::vector<std::vector<std::pair<int,int>>> c_cluster_set;
    int cluster_size = P_external_set.size();
    c_cluster_set.reserve(cluster_size);
    
    for (auto &entry : P_external_set)
    {
        std::vector<std::pair<int,int>> cluster;
        cluster.reserve(1);
        cluster.push_back(entry);
        c_cluster_set.push_back(std::move(cluster));
    }

    // Step 2: Goto step 5 if the set contains lesser or equal to max specified number
    for (; cluster_size > N_max_size_external_set; --cluster_size)
    {
        std::vector<std::pair<std::pair<int,int>, double>> solution_set;
        solution_set.reserve(cluster_size * cluster_size);
        
        // Step 3: Find the two sets with the minimum distance to each other
        // Using symmetry here, still O(N/2 * N/2)
        for (int i=0; i<cluster_size; ++i)
        {
            auto &cluster_1 = c_cluster_set[i];
            int cluster_1_size = cluster_1.size();

            // Skipping equal entries, since the distance would yield 0
            for (int j=i+1; j<cluster_size; ++j)
            {
                auto &cluster_2 = c_cluster_set[j];

                // This is supposed to be this d function
                double distance = 0.0;
                for (auto &cluster_1_entry : cluster_1)
                for (auto &cluster_2_entry : cluster_2)
                {
                    // Euklidian distance I suppose
                    int first_param = cluster_1_entry.first-cluster_2_entry.first;
                    int second_param = cluster_1_entry.second-cluster_2_entry.second;
                    distance += sqrt(first_param*first_param + second_param*second_param);
                }

                distance = (1.0/(cluster_1_size*cluster_2.size())) * distance;
                solution_set.push_back(std::make_pair(std::make_pair(i,j), std::move(distance)));
            }
        }

        // Step 4: Find pair with minimal distance
        std::pair<int,int> min_distance_pair = solution_set[0].first;
        double min_distance = solution_set[0].second;
        int solution_set_real_size = solution_set.size();
        for (int k=1; k<solution_set_real_size; ++k)
        {
            auto entry = solution_set[k];
            if (entry.second >= min_distance)
                continue;

            min_distance_pair = entry.first;
            min_distance = entry.second;
        }

        // Now merge the sets and create a new clusterset
        auto& firstSet = c_cluster_set[min_distance_pair.first];
        for (auto &entry : c_cluster_set[min_distance_pair.second])
            firstSet.push_back(std::move(entry));
        c_cluster_set.erase(c_cluster_set.begin()+min_distance_pair.second); 
    }

    // DEBUG: To see what is clustered
    for(auto &cluster : c_cluster_set)
        python_plot(stream, cluster);

    // Step 5: Return set of center points of each cluster
    for(auto &cluster : c_cluster_set)
    {
        // This is supposed to be this d function
        double min_distance;
        std::pair<int,int> min_distance_pair;
        bool firstOne = true;
        for (auto &cluster_entry_1 : cluster)
        {
            double distance = 0.0;
            for (auto &cluster_entry_2 : cluster)
            {
                // Ignore the same point
                if (&cluster_entry_1 == &cluster_entry_2)
                    continue;

                // Euklidian distance I suppose
                distance += sqrt((cluster_entry_1.first-cluster_entry_2.first) * (cluster_entry_1.first-cluster_entry_2.first) + (cluster_entry_1.second-cluster_entry_2.second)*(cluster_entry_1.second-cluster_entry_2.second));
            }

            if (!firstOne && min_distance <= distance)
                continue;

            min_distance = distance;
            min_distance_pair = cluster_entry_1;
            firstOne = false;
        }
        updated_external_set.push_back(std::move(min_distance_pair));
    }
}

// Probably incorrect, fixed in v4
void clustering_v3(std::ofstream &stream, std::vector<std::pair<int,int>> &P_external_set, std::vector<std::pair<int,int>> &updated_external_set, int N_max_size_external_set)
{
    // Step 1: 
    // Create a set of sets of clusters
    std::vector<std::vector<std::pair<int,int>>> c_cluster_set;
    int cluster_size = P_external_set.size();
    c_cluster_set.reserve(cluster_size);
    
    for (auto &entry : P_external_set)
    {
        std::vector<std::pair<int,int>> cluster;
        cluster.reserve(1);
        cluster.push_back(entry);
        c_cluster_set.push_back(std::move(cluster));
    }

    // Step 2: Goto step 5 if the set contains lesser or equal to max specified number
    std::vector<std::vector<double>> solution_set;
    solution_set.reserve(cluster_size-1);
    for (int i=0; i<cluster_size; ++i)
    {
        std::vector<double> inner_solution_set;
        inner_solution_set.reserve(cluster_size);
        for (int j=0; j<cluster_size; ++j)
            inner_solution_set.push_back(0.0);
        solution_set.push_back(std::move(inner_solution_set));
    }

    bool initial = true;
    double min_distance;
    int cluster_solution_index;
    for (; cluster_size > N_max_size_external_set; --cluster_size)
    {
        // Step 3: Find the two sets with the minimum distance to each other
        if (initial)
        {
            // Using symmetry here, still O(N/2 * N/2)
            for (int i=0; i<cluster_size; ++i)
            {
                auto &cluster_1 = c_cluster_set[i];
                int cluster_1_size = cluster_1.size();

                for (int j=i+1; j<cluster_size; ++j)
                {
                    auto &cluster_2 = c_cluster_set[j];

                    // This is supposed to be this d function
                    double distance = 0.0;
                    for (auto &cluster_1_entry : cluster_1)
                    for (auto &cluster_2_entry : cluster_2)
                    {
                        // Euklidian distance I suppose
                        int first_param = cluster_1_entry.first-cluster_2_entry.first;
                        int second_param = cluster_1_entry.second-cluster_2_entry.second;
                        distance += sqrt(first_param*first_param + second_param*second_param);
                    }
                    distance = (1.0/(cluster_1_size*cluster_2.size())) * distance;
                    solution_set[i][j] = std::move(distance);
                }
            }
            initial = false;
        }else{
            auto &cluster_1 = c_cluster_set[cluster_solution_index];
            int cluster_1_size = cluster_1.size();
            for (int j=0; j<cluster_size; ++j)
            {
                auto &cluster_2 = c_cluster_set[j];

                if (cluster_solution_index == j)
                    continue;

                // This is supposed to be this d function
                double distance = 0.0;
                for (auto &cluster_1_entry : cluster_1)
                for (auto &cluster_2_entry : cluster_2)
                {
                    // Euklidian distance I suppose
                    int first_param = cluster_1_entry.first-cluster_2_entry.first;
                    int second_param = cluster_1_entry.second-cluster_2_entry.second;
                    distance += sqrt(first_param*first_param + second_param*second_param);
                }

                distance = (1.0/(cluster_1_size*cluster_2.size())) * distance;
                solution_set[j][cluster_solution_index] = std::move(distance);
            }
        }

        // Step 4: Find pair with minimal distance
        int min_distance_x = 0;
        int min_distance_y = 0;
        min_distance = solution_set[0][0];
        int solution_set_real_size_x = solution_set.size();
        for (int x=0; x<solution_set_real_size_x; ++x)
        {
            if (min_distance > 0)
                break;

            int solution_set_real_size_y = solution_set[x].size();
            for (int y=0; y<solution_set_real_size_y; ++y)
            {
                min_distance = solution_set[x][y];
                min_distance_x = x;
                min_distance_y = y;
            }
        }

        for (int x=0; x<solution_set_real_size_x; ++x)
        {
            int solution_set_real_size_y = solution_set[x].size();
            for (int y=0; y<solution_set_real_size_y; ++y)
            {
                auto& distance = solution_set[x][y];
                if (distance >= min_distance || distance == 0.0)
                    continue;

                min_distance_x = x;
                min_distance_y = y;
                min_distance = distance;
            }
        }

        // Now merge the sets and create a new clusterset
        if (min_distance_x < min_distance_y)
        {
            auto& mergeSet = c_cluster_set[min_distance_x];
            for (auto &entry : c_cluster_set[min_distance_y])
                mergeSet.push_back(std::move(entry));
            cluster_solution_index = min_distance_x;
            c_cluster_set.erase(c_cluster_set.begin()+min_distance_y); 

            for (int q=0; q<cluster_size; ++q)
                solution_set[q].erase(solution_set[q].begin()+min_distance_y);
            solution_set.erase(solution_set.begin()+min_distance_y);
        }
        else
        {
            auto& mergeSet = c_cluster_set[min_distance_y];
            for (auto &entry : c_cluster_set[min_distance_x])
                mergeSet.push_back(std::move(entry));
            cluster_solution_index = min_distance_y;
            c_cluster_set.erase(c_cluster_set.begin()+min_distance_x); 

            for (int q=0; q<cluster_size; ++q)
                solution_set[q].erase(solution_set[q].begin()+min_distance_x);
            solution_set.erase(solution_set.begin()+min_distance_x);
        }
    }

    // DEBUG: To see what is clustered
    for(auto &cluster : c_cluster_set)
        python_plot(stream, cluster);

    // Step 5: Return set of center points of each cluster
    for(auto &cluster : c_cluster_set)
    {
        // This is supposed to be this d function
        double min_distance;
        std::pair<int,int> min_distance_pair;
        bool firstOne = true;
        for (auto &cluster_entry_1 : cluster)
        {
            double distance = 0.0;
            for (auto &cluster_entry_2 : cluster)
            {
                // Ignore the same point
                if (&cluster_entry_1 == &cluster_entry_2)
                    continue;

                // Euklidian distance I suppose
                distance += sqrt((cluster_entry_1.first-cluster_entry_2.first) * (cluster_entry_1.first-cluster_entry_2.first) + (cluster_entry_1.second-cluster_entry_2.second)*(cluster_entry_1.second-cluster_entry_2.second));
            }

            if (!firstOne && min_distance <= distance)
                continue;

            min_distance = distance;
            min_distance_pair = cluster_entry_1;
            firstOne = false;
        }
        updated_external_set.push_back(std::move(min_distance_pair));
    }
}

void clustering_v4(std::ofstream &stream, std::vector<std::pair<int,int>> &P_external_set, std::vector<std::pair<int,int>> &updated_external_set, int N_max_size_external_set)
{
    // Step 1: 
    // Create a set of sets of clusters
    std::vector<std::vector<std::pair<int,int>>> c_cluster_set;
    int cluster_size = P_external_set.size();
    c_cluster_set.reserve(cluster_size);
    
    for (auto &entry : P_external_set)
    {
        std::vector<std::pair<int,int>> cluster;
        cluster.reserve(1);
        cluster.push_back(entry);
        c_cluster_set.push_back(std::move(cluster));
    }

    // Step 2: Goto step 5 if the set contains lesser or equal to max specified number
    std::vector<std::vector<double>> solution_set;
    solution_set.reserve(cluster_size);
    for (int i=0; i<cluster_size; ++i)
    {
        std::vector<double> inner_solution_set;
        inner_solution_set.reserve(cluster_size-i);
        for (int j=0; j<cluster_size-i-1; ++j)
            inner_solution_set.push_back(0.0);
        solution_set.push_back(std::move(inner_solution_set));
    }

    bool initial = true;
    double min_distance;
    int cluster_solution_index;
    for (; cluster_size > N_max_size_external_set; --cluster_size)
    {
        //std::cout << " ------------------------------------- " << std::endl;
        // Step 3: Find the two sets with the minimum distance to each other
        if (initial)
        {
            // Using symmetry here, still O(N/2 * N/2)
            for (int i=0; i<cluster_size; ++i)
            {
                auto &cluster_1 = c_cluster_set[i];
                int cluster_1_size = cluster_1.size();

                for (int j=0; j<cluster_size-(i+1); ++j)
                {
                    auto &cluster_2 = c_cluster_set[cluster_size-1-j];

                    // This is supposed to be this d function
                    double distance = 0.0;
                    for (auto &cluster_1_entry : cluster_1)
                    for (auto &cluster_2_entry : cluster_2)
                    {
                        // Euklidian distance I suppose
                        int first_param = cluster_1_entry.first-cluster_2_entry.first;
                        int second_param = cluster_1_entry.second-cluster_2_entry.second;
                        distance += sqrt(first_param*first_param + second_param*second_param);
                    }
                    distance = (1.0/(cluster_1_size*cluster_2.size())) * distance;
                    solution_set[i][j] = std::move(distance);
                }
            }
        }else{
            auto &cluster_1 = c_cluster_set[cluster_solution_index];
            int cluster_1_size = cluster_1.size();
            //std::cout << cluster_solution_index << " // " << solution_set.size() << " // " << cluster_size << std::endl;
            // Here we need to evaluate two directions
            // First to the right
            for (int j=cluster_size-1; j>cluster_solution_index; --j)
            {
                auto &cluster_2 = c_cluster_set[j];

                // This is supposed to be this d function
                double distance = 0.0;
                for (auto &cluster_1_entry : cluster_1)
                for (auto &cluster_2_entry : cluster_2)
                {
                    // Euklidian distance I suppose
                    int first_param = cluster_1_entry.first-cluster_2_entry.first;
                    int second_param = cluster_1_entry.second-cluster_2_entry.second;
                    distance += sqrt(first_param*first_param + second_param*second_param);
                    //std::cout << cluster_solution_index << ", " << ((cluster_size)-j) << " => " << first_param <<  ", " << second_param << " => " << distance << " (" << cluster_1_entry.first << " - " << cluster_2_entry.first << "), (" << cluster_1_entry.second << ", " << cluster_2_entry.second << ")" << std::endl;
                }
                distance = (1.0/(cluster_1_size*cluster_2.size())) * distance;

                //std::cout << "Calculating: " << j << " => " << cluster_solution_index << ", " << ((cluster_size-1)-j) << " => " << distance << std::endl;
                //std::cout << "Inner: " << j << ", " << cluster_y_index << " // " << solution_set.size() << std::endl;
                solution_set[cluster_solution_index][(cluster_size-1)-j] = std::move(distance);
            }

            // Now down the graph
            for (int j=cluster_solution_index - 1; j>=0; --j)
            {
                auto &cluster_2 = c_cluster_set[j];

                // This is supposed to be this d function
                double distance = 0.0;
                for (auto &cluster_1_entry : cluster_1)
                for (auto &cluster_2_entry : cluster_2)
                {
                    // Euklidian distance I suppose
                    int first_param = cluster_1_entry.first-cluster_2_entry.first;
                    int second_param = cluster_1_entry.second-cluster_2_entry.second;
                    distance += sqrt(first_param*first_param + second_param*second_param);
                }
                distance = (1.0/(cluster_1_size*cluster_2.size())) * distance;
                //std::cout << "Calculating 2: " << j << " => " << distance << std::endl;
                //std::cout << j <<  " => " << distance << std::endl;
                solution_set[j][cluster_size-1-cluster_solution_index] = std::move(distance);
            }
        }

        // Step 4: Find pair with minimal distance
        int min_distance_x = 0;
        int min_distance_y = 0;
        min_distance = solution_set[0][0];
        int solution_set_real_size_x = solution_set.size();
        //std::cout << "Min Distance: " << min_distance << std::endl;
        for (int x=0; x<solution_set_real_size_x; ++x)
        {
            int solution_set_real_size_y = solution_set[x].size();
            for (int y=0; y<solution_set_real_size_y; ++y)
            {
                auto& distance = solution_set[x][y];
                if (distance >= min_distance || distance == 0.0)
                    continue;

                min_distance_x = x;
                min_distance_y = y;
                min_distance = distance;
            }
        }

        int min_distance_y_real = cluster_size-1-min_distance_y;
        /*
        std::cout << "Solution: " << min_distance_x << " / " << min_distance_y << " / " << min_distance << " => " << min_distance_y_real << std::endl;
        for (auto entry : c_cluster_set[min_distance_x])
            std::cout << "(" << entry.first <<  " , " << entry.second << "),";
        std::cout << std::endl;

        for (auto entry : c_cluster_set[min_distance_y_real])
            std::cout << "(" << entry.first <<  " , " << entry.second << "),";
        std::cout << std::endl;*/

        // Now merge the sets and create a new clusterset
        if (min_distance_x < min_distance_y_real)
        {
            auto& mergeSet = c_cluster_set[min_distance_x];
            for (auto &entry : c_cluster_set[min_distance_y_real])
                mergeSet.push_back(std::move(entry));
            cluster_solution_index = min_distance_x;
            c_cluster_set.erase(c_cluster_set.begin()+min_distance_y_real); 

        //std::cout << "TEST1: " << min_distance_y_real << " vs " << solution_set.size() << " => " << min_distance_y << " // " << solution_set[min_distance_y_real].size() << " => " << min_distance << std::endl;
            for (int q=0; q<cluster_size && min_distance_y < cluster_size-1-q; ++q)
            {
                //std::cout << min_distance_y << " <= " << (cluster_size-1-q) << " => " << q << std::endl;
                solution_set[q].erase(solution_set[q].begin()+min_distance_y);
            }
            solution_set.erase(solution_set.begin()+min_distance_y_real);
        //std::cout << "TEST3: " << min_distance_y_real << " vs " << solution_set.size() << " => " << min_distance_y << " // " << solution_set[min_distance_y_real].size() << std::endl;
            //if (min_distance_y_real - cluster_size > 1 || min_distance_y > 0)
                //solution_set.erase(solution_set.begin()+min_distance_y_real);
        }
        else
        {
            auto& mergeSet = c_cluster_set[min_distance_y_real];
            for (auto &entry : c_cluster_set[min_distance_x])
                mergeSet.push_back(std::move(entry));
            cluster_solution_index = min_distance_y_real;
            c_cluster_set.erase(c_cluster_set.begin()+min_distance_x); 

            for (int q=0; q<cluster_size && min_distance_x <= cluster_size-1-q; ++q)
                solution_set[q].erase(solution_set[q].begin()+min_distance_x);
            //std::cout << "TEST 2: " << min_distance_x << std::endl;
            solution_set.erase(solution_set.begin()+min_distance_x);
        }
        initial = false;
    }

    // DEBUG: To see what is clustered
    for(auto &cluster : c_cluster_set)
        python_plot(stream, cluster);

    // Step 5: Return set of center points of each cluster
    for(auto &cluster : c_cluster_set)
    {
        // This is supposed to be this d function
        double min_distance;
        std::pair<int,int> min_distance_pair;
        bool firstOne = true;
        for (auto &cluster_entry_1 : cluster)
        {
            double distance = 0.0;
            for (auto &cluster_entry_2 : cluster)
            {
                // Ignore the same point
                if (&cluster_entry_1 == &cluster_entry_2)
                    continue;

                // Euklidian distance I suppose
                distance += sqrt((cluster_entry_1.first-cluster_entry_2.first) * (cluster_entry_1.first-cluster_entry_2.first) + (cluster_entry_1.second-cluster_entry_2.second)*(cluster_entry_1.second-cluster_entry_2.second));
            }

            if (!firstOne && min_distance <= distance)
                continue;

            min_distance = distance;
            min_distance_pair = cluster_entry_1;
            firstOne = false;
        }
        updated_external_set.push_back(std::move(min_distance_pair));
    }
}

void clustering_v5(std::ofstream &stream, std::vector<std::pair<int,int>> &P_external_set, std::vector<std::pair<int,int>> &updated_external_set, int N_max_size_external_set)
{
    // Step 1: 
    // Create a set of sets of clusters
    std::vector<std::vector<std::pair<int,int>>> c_cluster_set;
    int cluster_size = P_external_set.size();
    c_cluster_set.reserve(cluster_size);
    
    for (auto &entry : P_external_set)
    {
        std::vector<std::pair<int,int>> cluster;
        cluster.reserve(1);
        cluster.push_back(entry);
        c_cluster_set.push_back(std::move(cluster));
    }

    // Step 2: Goto step 5 if the set contains lesser or equal to max specified number
    std::vector<std::vector<double>> solution_set;
    solution_set.reserve(cluster_size);
    for (int i=0; i<cluster_size; ++i)
    {
        std::vector<double> inner_solution_set;
        inner_solution_set.reserve(cluster_size-i);
        for (int j=0; j<cluster_size-i-1; ++j)
            inner_solution_set.push_back(0.0);
        solution_set.push_back(std::move(inner_solution_set));
    }

    // Step 3: Initialization
    double min_distance;
    int cluster_solution_index;
    // Using symmetry here, still O(N/2 * N/2)
    for (int i=0; i<cluster_size; ++i)
    {
        auto &cluster_1 = c_cluster_set[i];
        int cluster_1_size = cluster_1.size();

        for (int j=0; j<cluster_size-(i+1); ++j)
        {
            auto &cluster_2 = c_cluster_set[cluster_size-1-j];

            // This is supposed to be this d function
            double distance = 0.0;
            for (auto &cluster_1_entry : cluster_1)
            for (auto &cluster_2_entry : cluster_2)
            {
                // Euklidian distance I suppose
                int first_param = cluster_1_entry.first-cluster_2_entry.first;
                int second_param = cluster_1_entry.second-cluster_2_entry.second;
                distance += sqrt(first_param*first_param + second_param*second_param);
            }
            distance = (1.0/(cluster_1_size*cluster_2.size())) * distance;
            solution_set[i][j] = std::move(distance);
        }
    }
    goto cluster_v5_initial_skip;
    for (; cluster_size > N_max_size_external_set; --cluster_size)
    {
        {
            // Step 3: Find the two sets with the minimum distance to each other
            auto &cluster_1 = c_cluster_set[cluster_solution_index];
            int cluster_1_size = cluster_1.size();
            // Here we need to reevaluate in two directions
            // First to the right
            for (int j=cluster_size-1; j>cluster_solution_index; --j)
            {
                auto &cluster_2 = c_cluster_set[j];

                // This is supposed to be this d function
                double distance = 0.0;
                for (auto &cluster_1_entry : cluster_1)
                for (auto &cluster_2_entry : cluster_2)
                {
                    // Euklidian distance I suppose
                    int first_param = cluster_1_entry.first-cluster_2_entry.first;
                    int second_param = cluster_1_entry.second-cluster_2_entry.second;
                    distance += sqrt(first_param*first_param + second_param*second_param);
                }
                distance *= (1.0/(cluster_1_size*cluster_2.size()));
                solution_set[cluster_solution_index][(cluster_size-1)-j] = std::move(distance);
            }

            // Now down the graph
            for (int j=cluster_solution_index - 1; j>=0; --j)
            {
                auto &cluster_2 = c_cluster_set[j];

                // This is supposed to be this d function
                double distance = 0.0;
                for (auto &cluster_1_entry : cluster_1)
                for (auto &cluster_2_entry : cluster_2)
                {
                    // Euklidian distance I suppose
                    int first_param = cluster_1_entry.first-cluster_2_entry.first;
                    int second_param = cluster_1_entry.second-cluster_2_entry.second;
                    distance += sqrt(first_param*first_param + second_param*second_param);
                }
                distance *= (1.0/(cluster_1_size*cluster_2.size()));
                solution_set[j][cluster_size-1-cluster_solution_index] = std::move(distance);
            }
        }
        
        cluster_v5_initial_skip:
        
        // Step 4: Find pair with minimal distance
        int min_distance_x = 0;
        int min_distance_y = 0;
        min_distance = solution_set[0][0];
        int solution_set_real_size_x = solution_set.size();
        for (int x=0; x<solution_set_real_size_x; ++x)
        {
            int solution_set_real_size_y = solution_set[x].size();
            for (int y=0; y<solution_set_real_size_y; ++y)
            {
                auto& distance = solution_set[x][y];
                if (distance >= min_distance)
                    continue;

                min_distance_x = x;
                min_distance_y = y;
                min_distance = distance;
            }
        }

        // Now merge the sets and create a new clusterset
        int min_distance_y_real = cluster_size-1-min_distance_y;
        if (min_distance_x < min_distance_y_real)
        {
            auto& mergeSet = c_cluster_set[min_distance_x];
            for (auto &entry : c_cluster_set[min_distance_y_real])
                mergeSet.push_back(std::move(entry));
            cluster_solution_index = min_distance_x;
            c_cluster_set.erase(c_cluster_set.begin()+min_distance_y_real); 

            for (int q=0; q<cluster_size && min_distance_y < cluster_size-1-q; ++q)
                solution_set[q].erase(solution_set[q].begin()+min_distance_y);
            solution_set.erase(solution_set.begin()+min_distance_y_real);
        }
        else
        {
            auto& mergeSet = c_cluster_set[min_distance_y_real];
            for (auto &entry : c_cluster_set[min_distance_x])
                mergeSet.push_back(std::move(entry));
            cluster_solution_index = min_distance_y_real;
            c_cluster_set.erase(c_cluster_set.begin()+min_distance_x); 

            for (int q=0; q<cluster_size && min_distance_x <= cluster_size-1-q; ++q)
                solution_set[q].erase(solution_set[q].begin()+min_distance_x);
            solution_set.erase(solution_set.begin()+min_distance_x);
        }
    }

    // DEBUG: To see what is clustered
    for(auto &cluster : c_cluster_set)
        python_plot(stream, cluster);

    // Step 5: Return set of center points of each cluster
    // Symmetry can also be exploited here, but worth the effort?
    for(auto &cluster : c_cluster_set)
    {
        // This is supposed to be this d function
        double min_distance = 0.0;
        std::pair<int,int> min_distance_pair = cluster[0];

        int inner_cluster_size = cluster.size();
        for (int i=1; i<inner_cluster_size; ++i)
        {
            auto &cluster_entry_2 = cluster[i];
            min_distance += sqrt((min_distance_pair.first-cluster_entry_2.first) * (min_distance_pair.first-cluster_entry_2.first) + (min_distance_pair.second-cluster_entry_2.second)*(min_distance_pair.second-cluster_entry_2.second));
        }
        

        for (int i=0; i<inner_cluster_size; ++i)
        {
            auto &cluster_entry_1 = cluster[i];
            double distance = 0.0;
            for (int j=0; j<i; ++j)
            {
                auto &cluster_entry_2 = cluster[j];
                distance += sqrt((cluster_entry_1.first-cluster_entry_2.first) * (cluster_entry_1.first-cluster_entry_2.first) + (cluster_entry_1.second-cluster_entry_2.second)*(cluster_entry_1.second-cluster_entry_2.second));
            }

            for (int j=i+1; j<inner_cluster_size; ++j)
            {
                auto &cluster_entry_2 = cluster[j];
                distance += sqrt((cluster_entry_1.first-cluster_entry_2.first) * (cluster_entry_1.first-cluster_entry_2.first) + (cluster_entry_1.second-cluster_entry_2.second)*(cluster_entry_1.second-cluster_entry_2.second));
            }

            if (min_distance <= distance)
                continue;

            min_distance = std::move(distance);
            min_distance_pair = cluster_entry_1;
        }
        updated_external_set.push_back(std::move(min_distance_pair));
    }
}

void clustering_v6(std::vector<std::pair<int,int>> &data, int N_max_size_external_set)
{
    // Step 1: 
    // Create a set of sets of clusters
    std::vector<std::vector<std::pair<int,int>>> c_cluster_set;
    int cluster_size = data.size();
    c_cluster_set.reserve(cluster_size);
    
    for (auto &entry : data)
    {
        std::vector<std::pair<int,int>> cluster;
        cluster.reserve(1);
        cluster.push_back(entry);
        c_cluster_set.push_back(std::move(cluster));
    }

    // Step 2: Goto step 5 if the set contains lesser or equal to max specified number
    std::vector<std::vector<double>> solution_set;
    solution_set.reserve(cluster_size);
    for (int i=0; i<cluster_size; ++i)
    {
        std::vector<double> inner_solution_set;
        inner_solution_set.reserve(cluster_size-i);
        for (int j=0; j<cluster_size-i-1; ++j)
            inner_solution_set.push_back(0.0);
        solution_set.push_back(std::move(inner_solution_set));
    }

    // Step 3: Initialization
    double min_distance;
    int cluster_solution_index;
    // Using symmetry here, still O(N/2 * N/2)
    for (int i=0; i<cluster_size; ++i)
    {
        auto &cluster_1 = c_cluster_set[i];
        int cluster_1_size = cluster_1.size();

        for (int j=0; j<cluster_size-(i+1); ++j)
        {
            auto &cluster_2 = c_cluster_set[cluster_size-1-j];

            // This is supposed to be this d function
            double distance = 0.0;
            for (auto &cluster_1_entry : cluster_1)
            for (auto &cluster_2_entry : cluster_2)
            {
                // Euklidian distance I suppose
                int first_param = cluster_1_entry.first-cluster_2_entry.first;
                int second_param = cluster_1_entry.second-cluster_2_entry.second;
                distance += sqrt(first_param*first_param + second_param*second_param);
            }
            distance = (1.0/(cluster_1_size*cluster_2.size())) * distance;
            solution_set[i][j] = std::move(distance);
        }
    }
    goto cluster_v6_initial_skip;
    for (; cluster_size > N_max_size_external_set; --cluster_size)
    {
        {
            // Step 3: Find the two sets with the minimum distance to each other
            auto &cluster_1 = c_cluster_set[cluster_solution_index];
            int cluster_1_size = cluster_1.size();
            // Here we need to reevaluate in two directions
            // First to the right
            for (int j=cluster_size-1; j>cluster_solution_index; --j)
            {
                auto &cluster_2 = c_cluster_set[j];

                // This is supposed to be this d function
                double distance = 0.0;
                for (auto &cluster_1_entry : cluster_1)
                for (auto &cluster_2_entry : cluster_2)
                {
                    // Euklidian distance I suppose
                    int first_param = cluster_1_entry.first-cluster_2_entry.first;
                    int second_param = cluster_1_entry.second-cluster_2_entry.second;
                    distance += sqrt(first_param*first_param + second_param*second_param);
                }
                distance *= (1.0/(cluster_1_size*cluster_2.size()));
                solution_set[cluster_solution_index][(cluster_size-1)-j] = std::move(distance);
            }

            // Now down the graph
            for (int j=cluster_solution_index - 1; j>=0; --j)
            {
                auto &cluster_2 = c_cluster_set[j];

                // This is supposed to be this d function
                double distance = 0.0;
                for (auto &cluster_1_entry : cluster_1)
                for (auto &cluster_2_entry : cluster_2)
                {
                    // Euklidian distance I suppose
                    int first_param = cluster_1_entry.first-cluster_2_entry.first;
                    int second_param = cluster_1_entry.second-cluster_2_entry.second;
                    distance += sqrt(first_param*first_param + second_param*second_param);
                }
                distance *= (1.0/(cluster_1_size*cluster_2.size()));
                solution_set[j][cluster_size-1-cluster_solution_index] = std::move(distance);
            }
        }
        
        cluster_v6_initial_skip:
        
        // Step 4: Find pair with minimal distance
        int min_distance_x = 0;
        int min_distance_y = 0;
        min_distance = solution_set[0][0];
        int solution_set_real_size_x = solution_set.size();
        for (int x=0; x<solution_set_real_size_x; ++x)
        {
            int solution_set_real_size_y = solution_set[x].size();
            for (int y=0; y<solution_set_real_size_y; ++y)
            {
                auto& distance = solution_set[x][y];
                if (distance >= min_distance)
                    continue;

                min_distance_x = x;
                min_distance_y = y;
                min_distance = distance;
            }
        }

        // Now merge the sets and create a new clusterset
        int min_distance_y_real = cluster_size-1-min_distance_y;
        if (min_distance_x < min_distance_y_real)
        {
            c_cluster_set[min_distance_x].insert(
                c_cluster_set[min_distance_x].end(),
                std::make_move_iterator(c_cluster_set[min_distance_y_real].begin()),
                std::make_move_iterator(c_cluster_set[min_distance_y_real].end())
            );
            cluster_solution_index = min_distance_x;
            c_cluster_set.erase(c_cluster_set.begin()+min_distance_y_real); 

            for (int q=0; q<cluster_size && min_distance_y < cluster_size-1-q; ++q)
                solution_set[q].erase(solution_set[q].begin()+min_distance_y);
            solution_set.erase(solution_set.begin()+min_distance_y_real);
        }
        else
        {
            c_cluster_set[min_distance_y_real].insert(
                c_cluster_set[min_distance_y_real].end(),
                std::make_move_iterator(c_cluster_set[min_distance_x].begin()),
                std::make_move_iterator(c_cluster_set[min_distance_x].end())
            );
            cluster_solution_index = min_distance_y_real;
            c_cluster_set.erase(c_cluster_set.begin()+min_distance_x); 

            for (int q=0; q<cluster_size && min_distance_x <= cluster_size-1-q; ++q)
                solution_set[q].erase(solution_set[q].begin()+min_distance_x);
            solution_set.erase(solution_set.begin()+min_distance_x);
        }
    }

    // Step 5: Return set of center points of each cluster
    // Symmetry can also be exploited here, but worth the effort?
    data.clear();
    data.reserve(N_max_size_external_set);
    for(auto &cluster : c_cluster_set)
    {
        // This is supposed to be this d function
        double min_distance = 0.0;
        auto& min_distance_pair = cluster[0];

        int inner_cluster_size = cluster.size();
        for (int i=1; i<inner_cluster_size; ++i)
        {
            auto &cluster_entry_2 = cluster[i];
            min_distance += sqrt((min_distance_pair.first-cluster_entry_2.first) * (min_distance_pair.first-cluster_entry_2.first) + (min_distance_pair.second-cluster_entry_2.second)*(min_distance_pair.second-cluster_entry_2.second));
        }
        

        for (int i=0; i<inner_cluster_size; ++i)
        {
            auto &cluster_entry_1 = cluster[i];
            double distance = 0.0;
            for (int j=0; j<i; ++j)
            {
                auto &cluster_entry_2 = cluster[j];
                distance += sqrt((cluster_entry_1.first-cluster_entry_2.first) * (cluster_entry_1.first-cluster_entry_2.first) + (cluster_entry_1.second-cluster_entry_2.second)*(cluster_entry_1.second-cluster_entry_2.second));
            }

            for (int j=i+1; j<inner_cluster_size; ++j)
            {
                auto &cluster_entry_2 = cluster[j];
                distance += sqrt((cluster_entry_1.first-cluster_entry_2.first) * (cluster_entry_1.first-cluster_entry_2.first) + (cluster_entry_1.second-cluster_entry_2.second)*(cluster_entry_1.second-cluster_entry_2.second));
            }

            if (min_distance <= distance)
                continue;

            min_distance = std::move(distance);
            min_distance_pair = cluster_entry_1;
        }
        data.push_back(std::move(min_distance_pair));
    }
}

void clustering_divide_and_conquer(std::vector<std::pair<int,int>> &data, int data_length, int N_max_size_external_set)
{
    int half_length = static_cast<int>(data_length / 2);
    if (half_length > N_max_size_external_set)
    {
        std::vector<std::pair<int,int>> left(data.begin(), data.begin()+half_length);
        std::vector<std::pair<int,int>> right(data.begin()+half_length, data.end());
        clustering_divide_and_conquer(left, half_length, N_max_size_external_set);
        clustering_divide_and_conquer(right, data_length-half_length, N_max_size_external_set);
        left.insert(
            left.end(),
            std::make_move_iterator(right.begin()),
            std::make_move_iterator(right.end())
        );
        data = left;
    }
    clustering_v6(data, N_max_size_external_set);
}



/*
* Turns out that spawning threads all the time is a major overhead
* So I would need to make use of some thread pool which I would most likely not have access to in wcc
void clustering_divide_and_conquer_multithread(std::vector<std::pair<int,int>> &data, int data_length, int N_max_size_external_set);
struct clustering_argument {
    std::vector<std::pair<int,int>>* data;
    int data_length;
    int N_max_size_external_set;
} clustering_argument;
void *clustering_thread(void *args)
{
    struct clustering_argument *strct_args = (struct clustering_argument *)(args);
    clustering_v6(*(strct_args->data), strct_args->N_max_size_external_set);
    return NULL;
}
void *clustering_dac_thread(void *args)
{
    struct clustering_argument *strct_args = (struct clustering_argument *)(args);
    clustering_divide_and_conquer_multithread(*(strct_args->data), strct_args->data_length, strct_args->N_max_size_external_set);
    return NULL;
}

void clustering_divide_and_conquer_multithread(std::vector<std::pair<int,int>> &data, int data_length, int N_max_size_external_set)
{
    int half_length = static_cast<int>(data_length / 2);
    if (half_length > N_max_size_external_set)
    {
        pthread_t thread_left, thread_right;
        std::vector<std::pair<int,int>> left(data.begin(), data.begin()+half_length);
        std::vector<std::pair<int,int>> right(data.begin()+half_length, data.end());

        // One thread for each division
        struct clustering_argument thread_left_args;
        thread_left_args.data = &left;
        thread_left_args.data_length = half_length;
        thread_left_args.N_max_size_external_set = N_max_size_external_set;
        pthread_create( &thread_left, NULL, clustering_dac_thread, (void*) &thread_left_args);


        // Thread right
        struct clustering_argument thread_right_args;
        thread_right_args.data = &right;
        thread_right_args.data_length = data_length-half_length;
        thread_right_args.N_max_size_external_set = N_max_size_external_set;
        pthread_create( &thread_right, NULL, clustering_dac_thread, (void*) &thread_right_args);

        // Joining threads
        pthread_join( thread_left, NULL);
        pthread_join( thread_right, NULL);

        left.insert(
            left.end(),
            std::make_move_iterator(right.begin()),
            std::make_move_iterator(right.end())
        );
        data = left;
    }
    clustering_v6(data, N_max_size_external_set);
}
*/ 


/**
* Clustering implementation using a more general approach, i. e. C++ templates
**/
double euclidian_distance(std::pair<int,int> &p1, std::pair<int,int> &p2)
{
    int first_param = p1.first-p2.first;
    int second_param = p1.second-p2.second;
    return sqrt(first_param*first_param + second_param*second_param);
}

template <typename T>
void clustering(std::vector<T> &data, std::size_t N_max_size_external_set, double (*distance_measure)(T&,T&))
{
    // Step 1: 
    // Create a set of sets of clusters
    std::vector<std::vector<T>> c_cluster_set;
    std::size_t cluster_size = data.size();
    c_cluster_set.reserve(cluster_size);
    
    for (auto &entry : data)
    {
        std::vector<T> cluster;
        cluster.reserve(1);
        cluster.push_back(entry);
        c_cluster_set.push_back(std::move(cluster));
    }

    // Step 2: Goto step 5 if the set contains lesser or equal to max specified number
    std::vector<std::vector<double>> solution_set;
    solution_set.reserve(cluster_size);
    for (int i=0; i<cluster_size; ++i)
    {
        std::vector<double> inner_solution_set;
        inner_solution_set.reserve(cluster_size-i);
        for (int j=0; j<cluster_size-i-1; ++j)
            inner_solution_set.push_back(0.0);
        solution_set.push_back(std::move(inner_solution_set));
    }

    // Step 3: Initialization
    double min_distance;
    int cluster_solution_index;
    // Using symmetry here, still O(N/2 * N/2)
    for (int i=0; i<cluster_size; ++i)
    {
        auto &cluster_1 = c_cluster_set[i];
        int cluster_1_size = cluster_1.size();

        for (int j=0; j<cluster_size-(i+1); ++j)
        {
            auto &cluster_2 = c_cluster_set[cluster_size-1-j];

            // This is supposed to be this d function
            double distance = 0.0;
            for (auto &cluster_1_entry : cluster_1)
            for (auto &cluster_2_entry : cluster_2)
                distance += distance_measure(cluster_1_entry, cluster_2_entry);
            distance = (1.0/(cluster_1_size*cluster_2.size())) * distance;
            solution_set[i][j] = std::move(distance);
        }
    }
    goto cluster_initial_skip;
    for (; cluster_size > N_max_size_external_set; --cluster_size)
    {
        {
            // Step 3: Find the two sets with the minimum distance to each other
            auto &cluster_1 = c_cluster_set[cluster_solution_index];
            int cluster_1_size = cluster_1.size();
            // Here we need to reevaluate in two directions
            // First to the right
            for (int j=cluster_size-1; j>cluster_solution_index; --j)
            {
                auto &cluster_2 = c_cluster_set[j];

                // This is supposed to be this d function
                double distance = 0.0;
                for (auto &cluster_1_entry : cluster_1)
                for (auto &cluster_2_entry : cluster_2)
                {
                    // Euklidian distance I suppose
                    int first_param = cluster_1_entry.first-cluster_2_entry.first;
                    int second_param = cluster_1_entry.second-cluster_2_entry.second;
                    distance += sqrt(first_param*first_param + second_param*second_param);
                }
                distance *= (1.0/(cluster_1_size*cluster_2.size()));
                solution_set[cluster_solution_index][(cluster_size-1)-j] = std::move(distance);
            }

            // Now down the graph
            for (int j=cluster_solution_index - 1; j>=0; --j)
            {
                auto &cluster_2 = c_cluster_set[j];

                // This is supposed to be this d function
                double distance = 0.0;
                for (auto &cluster_1_entry : cluster_1)
                for (auto &cluster_2_entry : cluster_2)
                {
                    // Euklidian distance I suppose
                    int first_param = cluster_1_entry.first-cluster_2_entry.first;
                    int second_param = cluster_1_entry.second-cluster_2_entry.second;
                    distance += sqrt(first_param*first_param + second_param*second_param);
                }
                distance *= (1.0/(cluster_1_size*cluster_2.size()));
                solution_set[j][cluster_size-1-cluster_solution_index] = std::move(distance);
            }
        }
        
        cluster_initial_skip:
        
        // Step 4: Find pair with minimal distance
        int min_distance_x = 0;
        int min_distance_y = 0;
        min_distance = solution_set[0][0];
        int solution_set_real_size_x = solution_set.size();
        for (int x=0; x<solution_set_real_size_x; ++x)
        {
            int solution_set_real_size_y = solution_set[x].size();
            for (int y=0; y<solution_set_real_size_y; ++y)
            {
                auto& distance = solution_set[x][y];
                if (distance >= min_distance)
                    continue;

                min_distance_x = x;
                min_distance_y = y;
                min_distance = distance;
            }
        }

        // Now merge the sets and create a new clusterset
        int min_distance_y_real = cluster_size-1-min_distance_y;
        if (min_distance_x < min_distance_y_real)
        {
            c_cluster_set[min_distance_x].insert(
                c_cluster_set[min_distance_x].end(),
                std::make_move_iterator(c_cluster_set[min_distance_y_real].begin()),
                std::make_move_iterator(c_cluster_set[min_distance_y_real].end())
            );
            cluster_solution_index = min_distance_x;
            c_cluster_set.erase(c_cluster_set.begin()+min_distance_y_real); 

            for (int q=0; q<cluster_size && min_distance_y < cluster_size-1-q; ++q)
                solution_set[q].erase(solution_set[q].begin()+min_distance_y);
            solution_set.erase(solution_set.begin()+min_distance_y_real);
        }
        else
        {
            c_cluster_set[min_distance_y_real].insert(
                c_cluster_set[min_distance_y_real].end(),
                std::make_move_iterator(c_cluster_set[min_distance_x].begin()),
                std::make_move_iterator(c_cluster_set[min_distance_x].end())
            );
            cluster_solution_index = min_distance_y_real;
            c_cluster_set.erase(c_cluster_set.begin()+min_distance_x); 

            for (int q=0; q<cluster_size && min_distance_x <= cluster_size-1-q; ++q)
                solution_set[q].erase(solution_set[q].begin()+min_distance_x);
            solution_set.erase(solution_set.begin()+min_distance_x);
        }
    }

    // Step 5: Return set of center points of each cluster
    // Symmetry can also be exploited here, but worth the effort?
    data.clear();
    data.reserve(N_max_size_external_set);
    for(auto &cluster : c_cluster_set)
    {
        // This is supposed to be this d function
        double min_distance = 0.0;
        auto &min_distance_pair = cluster[0];

        int inner_cluster_size = cluster.size();
        for (int i=1; i<inner_cluster_size; ++i)
            min_distance += distance_measure(min_distance_pair, cluster[i]);
        

        for (int i=0; i<inner_cluster_size; ++i)
        {
            auto &cluster_entry_1 = cluster[i];
            double distance = 0.0;
            for (int j=0; j<i; ++j)
                distance += distance_measure(cluster_entry_1, cluster[j]);

            for (int j=i+1; j<inner_cluster_size; ++j)
                distance += distance_measure(cluster_entry_1, cluster[j]);

            if (min_distance <= distance)
                continue;

            min_distance = std::move(distance);
            min_distance_pair = cluster_entry_1;
        }
        data.push_back(std::move(min_distance_pair));
    }
}

template <typename T>
void clustering_dac(std::vector<T> &data, std::size_t data_length, std::size_t N_max_size_external_set, double (*distance_measure)(T&,T&))
{
    int half_length = static_cast<int>(data_length / 2);
    if (half_length > N_max_size_external_set)
    {
        std::vector<T> left(data.begin(), data.begin()+half_length);
        std::vector<T> right(data.begin()+half_length, data.end());
        clustering_dac(left, half_length, N_max_size_external_set, distance_measure);
        clustering_dac(right, data_length-half_length, N_max_size_external_set, distance_measure);
        left.insert(
            left.end(),
            std::make_move_iterator(right.begin()),
            std::make_move_iterator(right.end())
        );
        data = left;
    }
    clustering(data, N_max_size_external_set, distance_measure);
}



int main(int argc, char** argv)
{
    int grid_size = 25;
    int target_size = 9;

    std::vector<std::pair<int,int>> testData;
    auto stream = python_init_graph(grid_size, target_size);

    for (int i=0; i<grid_size; ++i)
    for (int j=0; j<grid_size; ++j)
        testData.push_back(std::make_pair(i,j));

    auto start = std::chrono::steady_clock::now();

    //clustering(testData, target_size, euclidian_distance);
    clustering_dac(testData, testData.size(), target_size, euclidian_distance);
    //clustering_v6(testData, target_size);
    //clustering_divide_and_conquer(testData, testData.size(), target_size);
    //clustering_divide_and_conquer_multithread(testData, testData.size(), target_size);

    auto end = std::chrono::steady_clock::now();
    
    python_plot(stream, testData, true);
    python_generate(stream, grid_size, target_size);

    auto diff = end - start;
    std::cout << "Algorithm runtime: " << std::chrono::duration<double, std::milli>(diff).count() << " ms" << std::endl;

    return 0;
}